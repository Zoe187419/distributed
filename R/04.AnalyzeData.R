################################################################################
### Functions for analyzing data at operations center
##
## Created on: 2016-06-17
## Author: Kazuki Yoshida
################################################################################



###
### Meta-analyses
################################################################################


##' Meta-analyze based on coefficient and variance vector
##'
##' Perform fixed-effect meta-analysis by inverse variance method, given a coefficient vector and a variance vector.
##'
##' @param coef vector of site-specific coefficients
##' @param var vector of site-specific variances
##'
##' @return a vector of meta-analysis coefficient and variance.
##'
##' @author Kazuki Yoshida
##'
##' @export
AnalyzeSiteRegressionHelper <- function(coef, var) {
    ## They must be of the same length to make sense
    assert_that(length(coef) == length(var))

    ## Check observations with missing coef or var
    ind_missing <- (is.na(coef) | is.na(var))

    if (all(ind_missing)) {
        ## If all of them are missing, no valid observation
        out <- c(coef = NA,
                 var  = NA)

    } else {
        ## Extract valid observations
        coef_cc <- coef[!ind_missing]
        var_cc  <- var[!ind_missing]
        ## Inverse variance weight meta-analysis
        ## https://en.wikipedia.org/wiki/Inverse-variance_weighting
        out <- c(coef = sum(coef_cc * (1 / var_cc)) / sum(1 / var_cc),
                 var  = 1                           / sum(1 / var_cc))
    }

    names(out) <- NULL
    return(out)
}


##' Meta-analyze regression results collected from data centers.
##'
##' Meta-analyze regression results collected from data centers. Pooling is conducted with inverse variance weighting (fixed effect meta-analysis).
##'
##' @param x data frame generated by \code{\link{RequestSiteRegression}}
##'
##' @return data frame populated with point estimates and variance estimates by various methods. Columns for site-specific coefficients are also retained for detailed assessments.
##'
##' @author Kazuki Yoshida
##'
##' @export
AnalyzeSiteRegression <- function(x) {
    assert_that(is.data.frame(x))

    out <- x %>%
        ## Group by outcome and methods
        split(f = x[c("outcome","method")], drop = TRUE) %>%
        lapply(function(df) {
            ## Obtain meta-analyzed results
            res <- AnalyzeSiteRegressionHelper(coef = df$coef,
                                               var  = df$var)
            ## Add labels
            data.frame(outcome = df$outcome[1],
                       method  = df$method[1],
                       coef    = res[1],
                       var     = res[2],
                       stringsAsFactors = FALSE)
        }) %>%
        do.call(what = rbind)
    rownames(out) <- NULL
    ## To be consistent with dplyr tools
    out <- dplyr::arrange_(out, "outcome", "method")

    ## Add data type
    out <- cbind(data = rep("meta", nrow(out)),
                 as.data.frame(out),
                 stringsAsFactors = FALSE)

    ## AUGMENT WITH INDIVIDUAL SITE DATA
    ## Individual site coefficients (spread after dropping variance column)
    out_sites <- tidyr::spread_(x[,-(which(names(x) == "var"))],
                                key_col = "site", value_col = "coef")
    names(out_sites)[-c(1,2)] <- paste0("coef_site", names(out_sites)[-c(1,2)])
    ## Must have the same number of rows
    assert_that(nrow(out) == nrow(out_sites))
    ## Augment results by left joining site-specific coefficients
    out_aug <- merge(x = out,
                     y = out_sites,
                     by = c("outcome","method"),
                     all.x = TRUE,  all.y = FALSE)

    ## Individual site variance (spread after dropping coef column)
    out_sites2 <- tidyr::spread_(x[,-(which(names(x) == "coef"))],
                                 key_col = "site", value_col = "var")
    names(out_sites2)[-c(1,2)] <- paste0("var_site", names(out_sites2)[-c(1,2)])
    ## Must have the same number of rows
    assert_that(nrow(out) == nrow(out_sites2))
    ## Augment results by left joining site-specific coefficients
    out_aug2 <- merge(x = out_aug,
                      y = out_sites2,
                      by = c("outcome","method"),
                      all.x = TRUE,  all.y = FALSE)

    out_aug2
}


###
### Summary-level conditional regressions
################################################################################

###  Binary

## Expanding back to IPD
## x is a summary-level data
ExpandToIpd <- function(x) {
    ## Check data
    assert_that(is.data.frame(x))
    assert_that(all(c("events","denom") %in% names(x)))
    assert_that(!("Y" %in% names(x)))

    ## List of each single row
    lstRows <- lapply(seq_len(nrow(x)), function(i) {
        x[i, , drop = FALSE]
    })

    ##
    lstOut <- lapply(lstRows, function(df) {
        ## Number of rows to create as copies
        n_new_rows <- df[,"denom"]
        n_event_rows <- df[,"events"]
        ## Create as many rows as denom (if NA just create one row)
        df <- df[rep(1, ifelse(is.na(n_new_rows), 1, n_new_rows)),]
        ## Fill Y with 0's if valid data
        df[,"Y"] <- ifelse(is.na(n_new_rows), as.numeric(NA), 0)
        ## Fill Y with 1's as many times as events (if not NA)
        if (!is.na(n_event_rows)) {
            df[,"Y"][seq_len(n_event_rows)] <- 1
        }
        ## Drop obsolete variables
        df[,"events"] <- NULL
        df[,"denom"] <- NULL
        ## Return df
        df
    })

    ## Combine into a data frame
    out <- do.call(rbind, lstOut)
    rownames(out) <- NULL
    out
}

##' Analyze summary-level binary data collected from data centers.
##'
##' Analyze summary-level binary data collected from data centers. PS- or DRS- matched analyses are conducted stratifying on sites. PS- or DRS-stratified analyses are conducted additionally stratifying on sites.
##'
##' @inheritParams AnalyzeSiteSummary
##'
##' @return list populated with vectors containing a pair of a point estimate and variance estimate for each method.
##'
##' @author Kazuki Yoshida
AnalyzeSiteSummaryBin <- function(x) {

    ## Only binary, expanded back to IPD
    ## Protect with try to avoid dying here.
    x <- try(ExpandToIpd(x[x$outcome == "binary",]))

    ## Binary
    ## Unadjusted stratified by sites
    unadjE       <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$method == "unadj",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Matched cohort stratified by sites
    ePsMatchE    <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$method == "ePsMatch",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    eDrsBMatchE  <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$method == "eDrsBMatch",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrataE   <- try(clogit(formula = Y ~ A + strata(site, strata),
                               data    = ValidateDf(x[x$method == "ePsStrata",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    eDrsBStrataE <- try(clogit(formula = Y ~ A + strata(site, strata),
                               data    = ValidateDf(x[x$method == "eDrsBStrata",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))

    ## Breslow
    ## Unadjusted stratified by sites
    unadjB       <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$method == "unadj",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Matched cohort stratified by sites
    ePsMatchB    <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$method == "ePsMatch",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    eDrsBMatchB  <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$method == "eDrsBMatch",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrataB   <- try(clogit(formula = Y ~ A + strata(site, strata),
                               data    = ValidateDf(x[x$method == "ePsStrata",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    eDrsBStrataB <- try(clogit(formula = Y ~ A + strata(site, strata),
                               data    = ValidateDf(x[x$method == "eDrsBStrata",],
                                                    expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))

    list(unadjE       = CoefVar(unadjE, "A"),
         ePsMatchE    = CoefVar(ePsMatchE, "A"),
         eDrsBMatchE  = CoefVar(eDrsBMatchE, "A"),
         ePsStrataE   = CoefVar(ePsStrataE, "A"),
         eDrsBStrataE = CoefVar(eDrsBStrataE, "A"),
         ## Breslow
         unadjB       = CoefVar(unadjB, "A"),
         ePsMatchB    = CoefVar(ePsMatchB, "A"),
         eDrsBMatchB  = CoefVar(eDrsBMatchB, "A"),
         ePsStrataB   = CoefVar(ePsStrataB, "A"),
         eDrsBStrataB = CoefVar(eDrsBStrataB, "A"))
}

###  Survival

##' Analyze summary-level survival data collected from data centers.
##'
##' Analyze summary-level survival data collected from data centers. PS- or DRS- matched analyses are conducted stratifying on sites. PS- or DRS-stratified analyses are conducted additionally stratifying on sites.
##'
##' @inheritParams AnalyzeSiteSummary
##'
##' @return list populated with vectors containing a pair of a point estimate and variance estimate for each method.
##'
##' @author Kazuki Yoshida
AnalyzeSiteSummarySurv <- function(x) {

    ## Only survival
    x <- x[x$outcome == "survival",]

    ## Survival
    ## Unadjusted stratified by sites
    unadj       <- try(gnm::gnm(formula   = events ~ A,
                                family    = poisson(link = "log"),
                                data      = ValidateDf(x[x$method == "unadj",],
                                                       expo_var = "A", event_var = "events"),
                                eliminate = factor(site),
                                offset    = log(denom)))
    ## Matched cohort stratified by sites
    ePsMatch    <- try(gnm::gnm(formula   = events ~ A,
                                family    = poisson(link = "log"),
                                data      = ValidateDf(x[x$method == "ePsMatch",],
                                                       expo_var = "A", event_var = "events"),
                                eliminate = factor(site),
                                offset    = log(denom)))
    eDrsSMatch  <- try(gnm::gnm(formula   = events ~ A,
                                family    = poisson(link = "log"),
                                data      = ValidateDf(x[x$method == "eDrsSMatch",],
                                                       expo_var = "A", event_var = "events"),
                                eliminate = factor(site),
                                offset    = log(denom)))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrata   <- try(gnm::gnm(formula   = events ~ A,
                                family    = poisson(link = "log"),
                                data      = ValidateDf(x[x$method == "ePsStrata",],
                                                       expo_var = "A", event_var = "events"),
                                eliminate = interaction(site, strata),
                                offset    = log(denom)))
    eDrsSStrata <- try(gnm::gnm(formula   = events ~ A,
                                family    = poisson(link = "log"),
                                data      = ValidateDf(x[x$method == "eDrsSStrata",],
                                                       expo_var = "A", event_var = "events"),
                                eliminate = interaction(site, strata),
                                offset    = log(denom)))

    list(unadj       = CoefVar(unadj, "A"),
         ePsMatch    = CoefVar(ePsMatch, "A"),
         eDrsSMatch  = CoefVar(eDrsSMatch, "A"),
         ePsStrata   = CoefVar(ePsStrata, "A"),
         eDrsSStrata = CoefVar(eDrsSStrata, "A"))
}

###  Combine
##' Analyze summary-level data collected from data centers.
##'
##' Analyze summary-level data collected from data centers. Summary score matched analyses and stratified analyses.
##'
##' @param x data frame generated by \code{\link{RequestSiteSummary}}, containing summary-level data.
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
AnalyzeSiteSummary <- function(x) {

    ##
    assert_that(is.data.frame(x))

    ## Coefficients and variances as a matrix
    lstBin  <- AnalyzeSiteSummaryBin(x)
    lstSurv <- AnalyzeSiteSummarySurv(x)
    matCoefVar <- do.call(rbind, c(lstBin, lstSurv))
    rownames(matCoefVar) <- NULL

    ## Name data
    out <- data.frame(data = rep("summary", nrow(matCoefVar)),
                      outcome = c(rep("binary", length(lstBin)),
                                  rep("survival", length(lstSurv))),
                      method = c(names(lstBin),
                                 names(lstSurv)),
                      stringsAsFactors = FALSE)

    ## Combine and return
    cbind(out, matCoefVar)
}


###
### Case-centered conditional logistic
################################################################################

###  Risk set expansion
##' Expand weighted risk set data with variance to long format.
##'
##' Expand weighted risk set-level data to individual-level data or summary long-format data. The weights are regenerated to maintain the given mean and variance. The individul-level data contain one row for each individual in each risk set. The summary long-format data are compressed so that each row represent multiple individuals. The count variable indicates how many individuals each row represent.
##'
##' @param x data frame generated by \code{\link{RequestSiteRisksets}}, containing risk set-level data.
##' @param compress defaults to \code{FALSE}. If true, the summary long-format data containing one row for each unique combination of variables including weights are created. The count variable indicates how many individuals each row represent.
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
RisksetsToIpd <- function(x, compress = FALSE) {
    ## Check data
    assert_that(is.data.frame(x))
    assert_that(all(c("site", "outcome", "method", "strata", "eval_time", "events_A0",
                      "events_A1", "riskset_A0", "riskset_A1", "w_events_A0", "w_events_A1",
                      "w_riskset_A0", "w_riskset_A1", "varw_events_A0", "varw_events_A1",
                      "varw_nonevents_A0", "varw_nonevents_A1") %in% names(x)))

    ## Create start-stop times
    time_increments <- diff(unique(sort(x$eval_time)))
    if (length(time_increments) == 0) {
        mini_inc <- 0.5
    } else {
        mini_inc <- 0.5 * min(time_increments)
    }

    ## Start stop times, make very small to avoid overlapping risk sets
    x$start_time <- x$eval_time
    x$stop_time  <- x$eval_time + mini_inc
    ## Drop
    x$eval_time <- NULL

    ## List of each single row
    lstRows <- lapply(seq_len(nrow(x)), function(i) {
        x[i, , drop = FALSE]
    })

    ##
    lstOut <- lapply(lstRows, function(df) {
        ## Keep original with one row
        df0 <- df

        ## Number of rows to create as copies
        n_new_A0_rows   <- df0[,"riskset_A0"]
        n_new_A1_rows   <- df0[,"riskset_A1"]
        n_event_A0_rows <- df0[,"events_A0"]
        n_event_A1_rows <- df0[,"events_A1"]

        ## Create as many rows as both risksets
        df <- df[rep(1, n_new_A0_rows + n_new_A1_rows),]

        ## Exposure status
        df[,"A"] <- 0
        df[seq_len(n_new_A1_rows),"A"] <- 1

        ## event status
        df[,"event"] <- 0
        df[df$A == 0,][seq_len(n_event_A0_rows), "event"] <- 1
        df[df$A == 1,][seq_len(n_event_A1_rows), "event"] <- 1

        ## weight assignment
        df[,"W"] <- NA
        ##
        df[df$A == 0 & df$event == 0, "W"] <-
            TwoPointSample(n = length(df[df$A == 0 & df$event == 0, "W"]),
                           mean = (df0[,"w_riskset_A0"] - df0[,"w_events_A0"]) /
                               (df0[,"riskset_A0"] - df0[,"events_A0"]),
                           var = df0[,"varw_nonevents_A0"])
        ##
        df[df$A == 0 & df$event == 1, "W"] <-
            TwoPointSample(n = length(df[df$A == 0 & df$event == 1, "W"]),
                           mean = df0[,"w_events_A0"] / df0[,"events_A0"],
                           var = df0[,"varw_events_A0"])
        ##
        df[df$A == 1 & df$event == 0, "W"] <-
            TwoPointSample(n = length(df[df$A == 1 & df$event == 0, "W"]),
                           mean = (df0[,"w_riskset_A1"] - df0[,"w_events_A1"]) /
                               (df0[,"riskset_A1"] - df0[,"events_A1"]),
                           var = df0[,"varw_nonevents_A1"])
        ##
        df[df$A == 1 & df$event == 1, "W"] <-
            TwoPointSample(n = length(df[df$A == 1 & df$event == 1, "W"]),
                           mean = df0[,"w_events_A1"] / df0[,"events_A1"],
                           var = df0[,"varw_events_A1"])

        ## Return df
        df[c("site","outcome","method","strata",
             "start_time","stop_time","A","event","W")]
    })

    ## Combine into a data frame
    out <- do.call(rbind, lstOut)

    ## Compress if asked for
    if (compress) {
        out <- out %>%
            dplyr::group_by_(.dots = c("site", "outcome", "method", "strata",
                                       "start_time", "stop_time", "A", "event", "W")) %>%
            dplyr::summarize_(count = ~ n()) %>%
            as.data.frame
    }

    rownames(out) <- NULL
    out
}


## Helper function
## n, m, v passed to SkewedTwoPointSample()
## A 0 or 1
## event 0 or 1
RisksetsToIpdSkewedHelper <- function(n, m, v, A, event, SampleFun = SkewedTwoPointSample) {
    ## All must be scalar
    assert_that(length(n) == 1)
    assert_that(length(m) == 1)
    assert_that(length(v) == 1)
    assert_that(length(A) == 1)
    assert_that(length(event) == 1)

    ## Data frame is returned by this
    out <- SampleFun(n = n, m = m, v = v)

    ## Add appropriate A and event columns to the left
    if (nrow(out) == 0) {
        out <- cbind(data.frame(A = as.numeric(), event = as.numeric()),
                     out)
    } else {
        n <- nrow(out)
        ## Data frame with n rows copying A and event
        df <- data.frame(A = A, event = event)[rep(1,n), ]

        out <- cbind(df,
                     out)
    }

    rownames(out) <- NULL
    out
}
## Version using Bruce's algorithm ExtremeTwoPointSample()
RisksetsToIpdExtremeHelper <- pryr::partial(RisksetsToIpdSkewedHelper,
                                            SampleFun = ExtremeTwoPointSample)


##' Expand weighted risk set data with variance to long format (enhanced).
##'
##' Expand weighted risk set-level data to individual-level data or summary long-format data. The weights are regenerated to maintain the given mean and variance. This version specifically try to avoid negative weights by skewing distribution. Also computation is based on the summary version, which is expaned when \code{compress = FALSE}. The individul-level data contain one row for each individual in each risk set. The summary long-format data are compressed so that each row represent multiple individuals. The count variable indicates how many individuals each row represent.
##'
##' @param x data frame generated by \code{\link{RequestSiteRisksets}}, containing risk set-level data.
##' @param compress defaults to \code{FALSE}. If true, the summary long-format data containing one row for each unique combination of variables including weights are created. The count variable indicates how many individuals each row represent.
##' @param helper_fun helper function used to regenerate weights given sample size \code{n}, sample mean \code{m}, sample variance \code{v}, and labeling for treatment \code{A} and event status \code{event}. Defaults to \code{RisksetsToIpdSkewedHelper}, which tries to balance the number of observations with above-mean and below-mean weights. \code{RisksetsToIpdExtremeHelper} will positions just one observation with an above-mean weight and all others below mean.
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
RisksetsToIpdSkewed <- function(x, compress, helper_fun = RisksetsToIpdSkewedHelper) {
    ## Check data
    assert_that(is.data.frame(x))
    assert_that(all(c("site", "outcome", "method", "strata", "eval_time", "events_A0",
                      "events_A1", "riskset_A0", "riskset_A1", "w_events_A0", "w_events_A1",
                      "w_riskset_A0", "w_riskset_A1", "varw_events_A0", "varw_events_A1",
                      "varw_nonevents_A0", "varw_nonevents_A1") %in% names(x)))

    ## Create start-stop times
    time_increments <- diff(unique(sort(x$eval_time)))
    if (length(time_increments) == 0) {
        mini_inc <- 0.5
    } else {
        mini_inc <- 0.5 * min(time_increments)
    }

    ## Start stop times, make very small to avoid overlapping risk sets
    x$start_time <- x$eval_time
    x$stop_time  <- x$eval_time + mini_inc
    ## Drop
    x$eval_time <- NULL

    ## List of each single row
    lstRows <- lapply(seq_len(nrow(x)), function(i) {
        x[i, , drop = FALSE]
    })

    ##
    lstOut <- lapply(lstRows, function(df) {

        ## Work on all four cells of 2x2 table individually
        df_A0_event0 <-
            helper_fun(n = (df[,"riskset_A0"] - df[,"events_A0"]),
                       m = (df[,"w_riskset_A0"] - df[,"w_events_A0"]) /
                           (df[,"riskset_A0"] - df[,"events_A0"]),
                       v = df[,"varw_nonevents_A0"],
                       A = 0, event = 0)
        ##
        df_A0_event1 <-
            helper_fun(n = df[,"events_A0"],
                       ## This can be NaN = 0/0
                       m = df[,"w_events_A0"] / df[,"events_A0"],
                       v = df[,"varw_events_A0"],
                       A = 0, event = 1)
        ##
        df_A1_event0 <-
            helper_fun(n = (df[,"riskset_A1"] - df[,"events_A1"]),
                       m = (df[,"w_riskset_A1"] - df[,"w_events_A1"]) /
                           (df[,"riskset_A1"] - df[,"events_A1"]),
                       v = df[,"varw_nonevents_A1"],
                       A = 1, event = 0)
        ##
        df_A1_event1 <-
            helper_fun(n = df[,"events_A1"],
                       ## This can be NaN = 0/0
                       m = df[,"w_events_A1"] / df[,"events_A1"],
                       v = df[,"varw_events_A1"],
                       A = 1, event = 1)

        ## Row bind to get the right side
        df_right <- rbind(df_A0_event0,
                          df_A0_event1,
                          df_A1_event0,
                          df_A1_event1)

        ## Repeat rows in the orignal to obtain the left side
        df_left <- df[rep(1, nrow(df_right)),
                      c("site","outcome","method","strata", "start_time","stop_time")]
        ## Return df
        cbind(df_left, df_right)
    })

    ## Combine into a data frame
    out <- do.call(rbind, lstOut)

    ## If compress == FALSE, expand by count and drop count
    if (compress == FALSE) {
        out <- out[rep(seq_along(out$count), out$count),]
        out$count <- NULL
    }

    rownames(out) <- NULL
    out
}


## Model specification
## SAS: https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_logistic_sect010.htm
##  exposed_events / total_events =  / offset = logodds_exposure
## R: https://stat.ethz.ch/pipermail/r-help/2008-August/170545.html
##  cbind(exposed_events, unexposed_events) ~ 1 + offset(logodds_exposure)

###  Analysis functions

##' Conduct case-centered analysis
##'
##' Given a specifically formatted data frame, conduct case-centered analysis
##'
##' @param df data frame containing one row for each riskset with the following variables: \code{events_A1} (event count among the exposed), \code{events_A0} (event count among the unexposed), \code{riskset_A1} (total count among the exposed including those who are having events), and \code{riskset_A0} (total count among the unexposed including those who are having events).
##'
##' @return \code{glm} fit object if successfully fit.
##'
##' @author Kazuki Yoshida
##'
##' @export
CaseCenteredLogistic <- function(df) {
    ## There must be some events for both groups to have reliable estimates
    assert_that(sum(df$events_A1, na.rm = TRUE) > 0)
    assert_that(sum(df$events_A0, na.rm = TRUE) > 0)

    ## Drop depleted time points with depeleted risksets
    df <- subset(df, riskset_A1 > 0 & riskset_A0 > 0)

    ## In R, use cbind(exposed_event_count, unexposed_event_count)
    ## Unlike SAS where it is exposed_event_count / total_event_count
    glm(formula = cbind(events_A1, events_A0) ~ 1,
        family  = binomial(link = "logit"),
        offset  = log(riskset_A1 / riskset_A0),
        data    = df)
}


###   Weighted analysis functions
##' Conduct case-centered analysis for weighted risk sets (Efron)
##'
##' Given a specifically formatted weighted data frame, conduct case-centered analysis by weighted individual-level data reconstruction. This one uses Efron approximation.
##'
##' @param df data frame containing one row for each riskset with the following variables: \code{events_A1} (event count among the exposed), \code{events_A0} (event count among the unexposed), \code{riskset_A1} (total count among the exposed including those who are having events), and \code{riskset_A0} (total count among the unexposed including those who are having events). The data frame additionally must contain valid weighted versions of these variables (\code{w_events_A1}, etc) and variance of weights for four types of cells defined by event and exposure status (\code{varw_events_A*} and \code{varw_nonevents_A*}), approximate weighted analysis is conducted.
##'
##' @return \code{svycoxph} fit object if successfully fit.
##'
##' @author Kazuki Yoshida
##'
##' @export
CaseCenteredLogisticWeightedEfron <- function(df) {

    ## Expand to individual patient data
    df_ipd <- RisksetsToIpdSkewed(df, compress = FALSE, helper_fun = RisksetsToIpdExtremeHelper)

    ## Check for valid data
    df_ipd <- ValidateDf(df_ipd, expo_var = "A", event_var = "event")

    ## Fit weighted Cox regression
    svycoxph(formula = Surv(start_time, stop_time, event) ~ A + strata(site),
             design  = svydesign(ids = ~ 1, weights = ~ W, data = df_ipd),
             ## For some reason, using an argument here did not owrk.
             method = "efron")
}

##' Conduct case-centered analysis for weighted risk sets (Breslow)
##'
##' Given a specifically formatted weighted data frame, conduct case-centered analysis by weighted individual-level data reconstruction. This one uses Breslow approximation.
##'
##' @inheritParams CaseCenteredLogisticWeightedEfron
##'
##' @return \code{svycoxph} fit object if successfully fit.
##'
##' @author Kazuki Yoshida
##'
##' @export
CaseCenteredLogisticWeightedBreslow <- function(df) {

    ## Expand to individual patient data
    df_ipd <- RisksetsToIpdSkewed(df, compress = FALSE, helper_fun = RisksetsToIpdExtremeHelper)

    ## Check for valid data
    df_ipd <- ValidateDf(df_ipd, expo_var = "A", event_var = "event")

    ## Fit weighted Cox regression
    svycoxph(formula = Surv(start_time, stop_time, event) ~ A + strata(site),
             design  = svydesign(ids = ~ 1, weights = ~ W, data = df_ipd),
             ## For some reason, using an argument here did not owrk.
             method = "breslow")
}


###   SAS-powered weighted analysis functions

##' Generate a SAS script to run PROC PHREG
##'
##' Generate a SAS script string with hard-coded input file, output file, approximation method, and stratification variables.
##'
##' @param datafile csv input data file path
##' @param method Either one of efron or breslow.
##' @param strata Specify space-deliminated names of stratifying variables.
##' @param outfile csv out data file path
##'
##' @return vector containing the name of SAS script file and planned output csv file name.
##'
##' @author Kazuki Yoshida
GenerateSasProcPhreg <- function(datafile, method, strata, outfile) {

    template_string <-
        "proc import datafile = '%s'
     out = wt_data
     dbms = dlm
     replace;
     delimiter = ',';
     getnames = yes;
run;

proc phreg data = wt_data covs outest = res covout;
    freq count;
    weight W;
    model (start_time, stop_time) * event(0) = A / ties = %s;
    strata %s;
run;

proc export data = res
   outfile = '%s'
   dbms = csv
   replace;
run;
"
    ## Fill in placeholders
    out_string <- sprintf(template_string,
                          datafile,
                          method,
                          strata,
                          outfile)

    ## Return a string with valid SAS syntax
    out_string
}


##' Conduct case-centered analysis for weighted risk sets via SAS
##'
##' Given a specifically formatted weighted data frame, conduct case-centered analysis by weighted individual-level data reconstruction. This command calls unix-style sas command. If sas is not available, it will stop with an error.
##'
##' @inheritParams CaseCenteredLogisticWeightedEfron
##' @param method Either efron or breslow
##' @param strata Specify space-deliminated names of stratifying variables.
##'
##' @return \code{sasfit} object with \code{coef} and \code{vcov} methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
CaseCenteredLogisticWeightedSas <- function(df, method, strata) {
    assert_that(is.character(method))
    assert_that(is.character(strata))
    assert_that(length(method) == 1)
    assert_that(length(strata) == 1)

    ## Check for the availability of sas command
    if (length(suppressWarnings(system("type sas", intern = TRUE, ignore.stderr = TRUE))) == 0) {
        stop("sas command not available. Aborting.")
    }

    ## Expand to individual patient data
    df_comp <- RisksetsToIpdSkewed(df, compress = TRUE, helper_fun = RisksetsToIpdExtremeHelper)

    ## Check for valid data
    df_comp <- ValidateDf(df_comp, expo_var = "A", event_var = "event")

    ## Temporary file names
    file_name <- tempfile()
    ## Input file
    input_file_name  <- paste0(file_name, "_input.csv")
    ## Output file
    output_file_name <- paste0(file_name, "_output.csv")
    ## SAS script file
    sas_file_name    <- paste0(file_name, "_script.sas")

    ## Write csv input file
    ## SIDE-EFFECT
    write.csv(df_comp, file = input_file_name, row.names = FALSE)

    ## SAS script as a string
    sas_string <- GenerateSasProcPhreg(datafile = input_file_name,
                                       method   = method,
                                       strata   = strata,
                                       outfile  = output_file_name)
    ## Write to a script file
    fileConn <- file(sas_file_name)
    writeLines(sas_string, fileConn)
    close(fileConn)

    ## Run SAS script
    system(paste("sas ", sas_file_name))

    ## Load output file generated by SAS
    res <- read.csv(output_file_name)

    ## File cleanup
    file.remove(input_file_name)
    file.remove(sas_file_name)
    file.remove(output_file_name)
    ## SAS log and lst files appear in the current directory where R script was invoked.
    ## Use basename to remove irrelevant path to specify files in current directory.
    file.remove(basename(paste0(tools::file_path_sans_ext(sas_file_name), ".log")))
    file.remove(basename(paste0(tools::file_path_sans_ext(sas_file_name), ".lst")))

    ## First row is coefficient
    res_coef <- as.numeric(res[1,"A"])
    names(res_coef) <- "A"

    ## Second row is variance
    res_vcov <- as.matrix(as.numeric(res[2,"A"]))
    rownames(res_vcov) <- "A"
    colnames(res_vcov) <- "A"

    ## Combine into a list
    out <- list(coef = res_coef,
                vcov = res_vcov)

    ## Give sasfit class
    class(out) <- c("sasfit", class(out))
    out
}

coef.sasfit <- function(x, ...) {
    x$coef
}

vcov.sasfit <- function(x, ...) {
    x$vcov
}


###   Unified analysis functions
## Binary
AnalyzeSiteRisksetsBin <- function(x) {

    assert_that(all(x$outcome == "binary"))

    ## Unweighted data
    ## Unadjusted
    unadj       <- try(CaseCenteredLogistic(x[x$method == "unadj",]))
    ## Matched cohort stratified by sites
    ePsMatch    <- try(CaseCenteredLogistic(x[x$method == "ePsMatch",]))
    eDrsBMatch  <- try(CaseCenteredLogistic(x[x$method == "eDrsBMatch",]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrata   <- try(CaseCenteredLogistic(x[x$method == "ePsStrata",]))
    eDrsBStrata <- try(CaseCenteredLogistic(x[x$method == "eDrsBStrata",]))
    ## Weighted analyses
    ## Efron
    ePsSIptwE   <- try(CaseCenteredLogisticWeightedEfron(x[x$method == "ePsSIptw",]))
    ePsMwE      <- try(CaseCenteredLogisticWeightedEfron(x[x$method == "ePsMw",]))
    ## Breslow
    ePsSIptwB   <- try(CaseCenteredLogisticWeightedBreslow(x[x$method == "ePsSIptw",]))
    ePsMwB      <- try(CaseCenteredLogisticWeightedBreslow(x[x$method == "ePsMw",]))

    list(unadj       = CoefVar(unadj, "(Intercept)"),
         ePsMatch    = CoefVar(ePsMatch, "(Intercept)"),
         eDrsBMatch  = CoefVar(eDrsBMatch, "(Intercept)"),
         ePsStrata   = CoefVar(ePsStrata, "(Intercept)"),
         eDrsBStrata = CoefVar(eDrsBStrata, "(Intercept)"),
         ## These are on reproduced IPD, thus, A is available.
         ePsSIptwE   = CoefVar(ePsSIptwE, "A"),
         ePsMwE      = CoefVar(ePsMwE, "A"),
         ePsSIptwB   = CoefVar(ePsSIptwB, "A"),
         ePsMwB      = CoefVar(ePsMwB, "A")
         )

}

## Survival
## Weighted analysis turned off for now
AnalyzeSiteRisksetsSurv <- function(x) {

    assert_that(all(x$outcome == "survival"))

    ## Unweighted data
    unadj       <- try(CaseCenteredLogistic(x[x$method == "unadj",]))
    ## Matched cohort stratified by sites
    ePsMatch    <- try(CaseCenteredLogistic(x[x$method == "ePsMatch",]))
    eDrsSMatch  <- try(CaseCenteredLogistic(x[x$method == "eDrsSMatch",]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrata   <- try(CaseCenteredLogistic(x[x$method == "ePsStrata",]))
    eDrsSStrata <- try(CaseCenteredLogistic(x[x$method == "eDrsSStrata",]))
    ## Weighted analyses
    ## Efron
    ePsSIptwE   <- try(CaseCenteredLogisticWeightedSas(x[x$method == "ePsSIptw",],
                                                       method = "efron",
                                                       strata = "site"))
    ePsMwE      <- try(CaseCenteredLogisticWeightedSas(x[x$method == "ePsMw",],
                                                       method = "efron",
                                                       strata = "site"))
    ## Breslow
    ePsSIptwB   <- try(CaseCenteredLogisticWeightedSas(x[x$method == "ePsSIptw",],
                                                       method = "breslow",
                                                       strata = "site"))
    ePsMwB      <- try(CaseCenteredLogisticWeightedSas(x[x$method == "ePsMw",],
                                                       method = "breslow",
                                                       strata = "site"))

    list(unadj       = CoefVar(unadj, "(Intercept)"),
         ePsMatch    = CoefVar(ePsMatch, "(Intercept)"),
         eDrsSMatch  = CoefVar(eDrsSMatch, "(Intercept)"),
         ePsStrata   = CoefVar(ePsStrata, "(Intercept)"),
         eDrsSStrata = CoefVar(eDrsSStrata, "(Intercept)"),
         ## ## These are on reproduced IPD, thus, A is available.
         ePsSIptwE   = CoefVar(ePsSIptwE, "A"),
         ePsMwE      = CoefVar(ePsMwE, "A"),
         ePsSIptwB   = CoefVar(ePsSIptwB, "A"),
         ePsMwB      = CoefVar(ePsMwB, "A")
         )

}


##' Analyze risk set-level data collected from data centers.
##'
##' Analyze risk set-level data collected from data centers. Case-centered conditional logistic regression is conducted conditioning on risk sets. Risk sets are finer than strata and sites, thus, strata and sites are effectively conditioned on.
##'
##' @param x data frame generated by \code{\link{RequestSiteRisksets}}
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
AnalyzeSiteRisksets <- function(x) {
    assert_that(is.data.frame(x))

    lstBin  <- AnalyzeSiteRisksetsBin(x[x$outcome == "binary", ])
    lstSurv <- AnalyzeSiteRisksetsSurv(x[x$outcome == "survival", ])
    matCoefVar <- do.call(rbind, c(lstBin, lstSurv))
    rownames(matCoefVar) <- NULL

    ## Name data
    out <- data.frame(data = rep("risksets", nrow(matCoefVar)),
                      outcome = c(rep("binary", length(lstBin)),
                                  rep("survival", length(lstSurv))),
                      method = c(names(lstBin),
                                 names(lstSurv)),
                      stringsAsFactors = FALSE)

    ## Combine and return
    cbind(out, matCoefVar)
}


###
### Regular regressions
################################################################################

###  Binary
##' Analyze individual-level binary data collected from data centers.
##'
##' Analyze individual-level binary data collected from data centers. PS- or DRS- matched analyses are conducted stratifying on sites. PS- or DRS-stratified analyses are conducted additionally stratifying on sites. PS-weighted analyses (stabilized IPTW and MW) are conducted stratifying on sites via \code{svycoxph} (conditional logisitc regression using a dummy constant time as the time variable).
##'
##' @inheritParams AnalyzeSiteDataset
##'
##' @return list populated with vectors containing a pair of a point estimate and variance estimate for each method.
##'
##' @author Kazuki Yoshida
AnalyzeSiteDatasetBin <- function(x) {
    ## Binary
    ## Unadjusted stratified by sites
    unadjE       <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x, expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Matched cohort stratified by sites
    ePsMatchE    <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$ePsMatch == 1,], expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    eDrsBMatchE  <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$eDrsBMatch == 1,], expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrataE   <- try(clogit(formula = Y ~ A + strata(site, ePsStrata),
                               data    = ValidateDf(x, expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    eDrsBStrataE <- try(clogit(formula = Y ~ A + strata(site, eDrsBStrata),
                               data    = ValidateDf(x, expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Weighted analysis stratified by sites
    ePsSIptwE    <- try(svycoxph(formula = Surv(rep(1, length(Y)), Y) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "Y"),
                                                     weights = ~ ePsSIptw),
                                 method  = c("exact", "approximate", "efron", "breslow")[3]))
    ePsMwE       <- try(svycoxph(formula = Surv(rep(1, length(Y)), Y) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "Y"),
                                                     weights = ~ ePsMw),
                                 method  = c("exact", "approximate", "efron", "breslow")[3]))

    ## Breslow
    ## Unadjusted stratified by sites
    unadjB       <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x, expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Matched cohort stratified by sites
    ePsMatchB    <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$ePsMatch == 1,], expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    eDrsBMatchB  <- try(clogit(formula = Y ~ A + strata(site),
                               data    = ValidateDf(x[x$eDrsBMatch == 1,], expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrataB   <- try(clogit(formula = Y ~ A + strata(site, ePsStrata),
                               data    = ValidateDf(x, expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    eDrsBStrataB <- try(clogit(formula = Y ~ A + strata(site, eDrsBStrata),
                               data    = ValidateDf(x, expo_var = "A", event_var = "Y"),
                               method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Weighted analysis stratified by sites
    ePsSIptwB    <- try(svycoxph(formula = Surv(rep(1, length(Y)), Y) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "Y"),
                                                     weights = ~ ePsSIptw),
                                 method  = c("exact", "approximate", "efron", "breslow")[4]))
    ePsMwB       <- try(svycoxph(formula = Surv(rep(1, length(Y)), Y) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "Y"),
                                                     weights = ~ ePsMw),
                                 method  = c("exact", "approximate", "efron", "breslow")[4]))

    list(unadjE       = CoefVar(unadjE, "A"),
         ePsMatchE    = CoefVar(ePsMatchE, "A"),
         eDrsBMatchE  = CoefVar(eDrsBMatchE, "A"),
         ePsStrataE   = CoefVar(ePsStrataE, "A"),
         eDrsBStrataE = CoefVar(eDrsBStrataE, "A"),
         ePsSIptwE    = CoefVar(ePsSIptwE, "A"),
         ePsMwE       = CoefVar(ePsMwE, "A"),
         ## Breslow
         unadjB       = CoefVar(unadjB, "A"),
         ePsMatchB    = CoefVar(ePsMatchB, "A"),
         eDrsBMatchB  = CoefVar(eDrsBMatchB, "A"),
         ePsStrataB   = CoefVar(ePsStrataB, "A"),
         eDrsBStrataB = CoefVar(eDrsBStrataB, "A"),
         ePsSIptwB    = CoefVar(ePsSIptwB, "A"),
         ePsMwB       = CoefVar(ePsMwB, "A"))
}


###  Survival
##' Analyze individual-level survival data collected from data centers.
##'
##' Analyze individual-level survival data collected from data centers. PS- or DRS- matched analyses are conducted stratifying on sites. PS- or DRS-stratified analyses are conducted additionally stratifying on sites. PS-weighted analyses (stabilized IPTW and MW) are conducted stratifying on sites via \code{svycoxph}.
##'
##' @inheritParams AnalyzeSiteDataset
##'
##' @return list populated with vectors containing a pair of a point estimate and variance estimate for each method.
##'
##' @author Kazuki Yoshida
AnalyzeSiteDatasetSurv <- function(x) {
    ## Survival
    ## Unadjusted stratified by sites
    unadjE       <- try(coxph(formula = Surv(time, event) ~ A + strata(site),
                              data    = ValidateDf(x, expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Matched cohort stratified by sites
    ePsMatchE    <- try(coxph(formula = Surv(time, event) ~ A + strata(site),
                              data    = ValidateDf(x[x$ePsMatch == 1,], expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[3]))
    eDrsSMatchE  <- try(coxph(formula = Surv(time, event) ~ A + strata(site),
                              data    = ValidateDf(x[x$eDrsSMatch == 1,], expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrataE   <- try(coxph(formula = Surv(time, event) ~ A + strata(site, ePsStrata),
                              data    = ValidateDf(x, expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[3]))
    eDrsSStrataE <- try(coxph(formula = Surv(time, event) ~ A + strata(site, eDrsSStrata),
                              data    = ValidateDf(x, expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Weighted analysis stratified by sites
    ePsSIptwE    <- try(svycoxph(formula = Surv(time, event) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "event"),
                                                     weights = ~ ePsSIptw),
                                 method  = c("exact", "approximate", "efron", "breslow")[3]))
    ePsMwE       <- try(svycoxph(formula = Surv(time, event) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "event"),
                                                     weights = ~ ePsMw),
                                 method  = c("exact", "approximate", "efron", "breslow")[3]))

    ## Breslow
    ## Unadjusted stratified by sites
    unadjB       <- try(coxph(formula = Surv(time, event) ~ A + strata(site),
                              data    = ValidateDf(x, expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Matched cohort stratified by sites
    ePsMatchB    <- try(coxph(formula = Surv(time, event) ~ A + strata(site),
                              data    = ValidateDf(x[x$ePsMatch == 1,], expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[4]))
    eDrsSMatchB  <- try(coxph(formula = Surv(time, event) ~ A + strata(site),
                              data    = ValidateDf(x[x$eDrsSMatch == 1,], expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Stratified analysis stratified by summary score strata and sites
    ePsStrataB   <- try(coxph(formula = Surv(time, event) ~ A + strata(site, ePsStrata),
                              data    = ValidateDf(x, expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[4]))
    eDrsSStrataB <- try(coxph(formula = Surv(time, event) ~ A + strata(site, eDrsSStrata),
                              data    = ValidateDf(x, expo_var = "A", event_var = "event"),
                              method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Weighted analysis stratified by sites
    ePsSIptwB    <- try(svycoxph(formula = Surv(time, event) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "event"),
                                                     weights = ~ ePsSIptw),
                                 method  = c("exact", "approximate", "efron", "breslow")[4]))
    ePsMwB       <- try(svycoxph(formula = Surv(time, event) ~ A + strata(site),
                                 design  = svydesign(ids = ~ 1,
                                                     data = ValidateDf(x, expo_var = "A", event_var = "event"),
                                                     weights = ~ ePsMw),
                                 method  = c("exact", "approximate", "efron", "breslow")[4]))

    list(unadjE       = CoefVar(unadjE, "A"),
         ePsMatchE    = CoefVar(ePsMatchE, "A"),
         eDrsSMatchE  = CoefVar(eDrsSMatchE, "A"),
         ePsStrataE   = CoefVar(ePsStrataE, "A"),
         eDrsSStrataE = CoefVar(eDrsSStrataE, "A"),
         ePsSIptwE    = CoefVar(ePsSIptwE, "A"),
         ePsMwE       = CoefVar(ePsMwE, "A"),
         ## Breslow
         unadjB       = CoefVar(unadjB, "A"),
         ePsMatchB    = CoefVar(ePsMatchB, "A"),
         eDrsSMatchB  = CoefVar(eDrsSMatchB, "A"),
         ePsStrataB   = CoefVar(ePsStrataB, "A"),
         eDrsSStrataB = CoefVar(eDrsSStrataB, "A"),
         ePsSIptwB    = CoefVar(ePsSIptwB, "A"),
         ePsMwB       = CoefVar(ePsMwB, "A"))
}


###  Combined
##' Analyze individual-level data collected from data centers.
##'
##' Analyze individual-level data collected from data centers. Summary score matched analyses, stratified analyses, and weighted analyses are conducted stratifying on sites.
##'
##' @param x data frame generated by \code{\link{RequestSiteDataset}}, containing summary score matching, stratification, and weighting variables.
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
AnalyzeSiteDataset <- function(x) {

    ##
    assert_that(is.data.frame(x))
    ## All variables need to exist
    assert_that(all(c("ePsMatch", "eDrsBMatch",
                      "ePsStrata", "eDrsBStrata",
                      "ePsSIptw", "ePsMw",
                      "ePsMatch", "eDrsSMatch",
                      "ePsStrata", "eDrsSStrata",
                      "ePsSIptw", "ePsMw") %in% names(x)))

    ## Coefficients and variances as a matrix
    lstBin  <- AnalyzeSiteDatasetBin(x)
    lstSurv <- AnalyzeSiteDatasetSurv(x)
    matCoefVar <- do.call(rbind, c(lstBin, lstSurv))
    rownames(matCoefVar) <- NULL

    ## Name data
    out <- data.frame(data = rep("dataset", nrow(matCoefVar)),
                      outcome = rep(c("binary","survival"),
                                    c(length(lstBin), length(lstSurv))),
                      method = c(names(lstBin),
                                 names(lstSurv)),
                      stringsAsFactors = FALSE)

    ## Combine and return
    cbind(out, matCoefVar)
}


###
### Counterfactual regressions
################################################################################

###  Binary
##' Analyze individual-level binary data collected from data centers (counterfactuals)
##'
##' Analyze individual-level binary data collected from data centers. PS- or DRS- matched analyses are conducted stratifying on sites. PS- or DRS-stratified analyses are conducted additionally stratifying on sites. PS-weighted analyses (stabilized IPTW and MW) are conducted stratifying on sites via \code{svycoxph} (conditional logisitc regression using a dummy constant time as the time variable).
##'
##' @inheritParams AnalyzeSiteTruth
##'
##' @return list populated with vectors containing a pair of a point estimate and variance estimate for each method.
##'
##' @author Kazuki Yoshida
AnalyzeSiteTruthBin <- function(x) {

    ## Binary
    ## Use counterfactual binary outcome Y_ and intervened treatment A_
    ## Causal effect in the entire sample stratified on sites
    tAllE      <- try(clogit(formula = Y_ ~ A_ + strata(site),
                             data    = ValidateDf(x, expo_var = "A_", event_var = "Y_"),
                             method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Causal effect in the treated sub-sample stratified on sites
    tTreatedE  <- try(clogit(formula = Y_ ~ A_ + strata(site),

                             data    = ValidateDf(x[x$A == 1,], expo_var = "A_", event_var = "Y_"),
                             method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Causal effect in the untreated sub-sample stratified on sites
    tUntreatedE <- try(clogit(formula = Y_ ~ A_ + strata(site),
                              data    = ValidateDf(x[x$A == 0,], expo_var = "A_", event_var = "Y_"),
                              method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Breslow
    ## Causal effect in the entire sample stratified on sites
    tAllB      <- try(clogit(formula = Y_ ~ A_ + strata(site),
                             data    = ValidateDf(x, expo_var = "A_", event_var = "Y_"),
                             method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Causal effect in the treated sub-sample stratified on sites
    tTreatedB  <- try(clogit(formula = Y_ ~ A_ + strata(site),

                             data    = ValidateDf(x[x$A == 1,], expo_var = "A_", event_var = "Y_"),
                             method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Causal effect in the untreated sub-sample stratified on sites
    tUntreatedB <- try(clogit(formula = Y_ ~ A_ + strata(site),
                              data    = ValidateDf(x[x$A == 0,], expo_var = "A_", event_var = "Y_"),
                              method  = c("exact", "approximate", "efron", "breslow")[4]))

    list(tAllE       = CoefVar(tAllE, "A_"),
         tTreatedE   = CoefVar(tTreatedE, "A_"),
         tUntreatedE = CoefVar(tUntreatedE, "A_"),
         ## Breslow
         tAllB       = CoefVar(tAllB, "A_"),
         tTreatedB   = CoefVar(tTreatedB, "A_"),
         tUntreatedB = CoefVar(tUntreatedB, "A_"))
}


###  Survival
##' Analyze individual-level survival data collected from data centers (counterfactuals)
##'
##' Analyze individual-level survival data collected from data centers. PS- or DRS- matched analyses are conducted stratifying on sites. PS- or DRS-stratified analyses are conducted additionally stratifying on sites. PS-weighted analyses (stabilized IPTW and MW) are conducted stratifying on sites via \code{svycoxph}.
##'
##' @inheritParams AnalyzeSiteTruth
##'
##' @return list populated with vectors containing a pair of a point estimate and variance estimate for each method.
##'
##' @author Kazuki Yoshida
AnalyzeSiteTruthSurv <- function(x) {
    ## Survival
    ## Use counterfactual event time T_ and intervened treatment A_; event_ is all 1's.
    ## Causal effect in the entire sample stratified on sites
    tAllE      <- try(coxph(formula = Surv(T_, event_) ~ A_ + strata(site),
                            data    = ValidateDf(x, expo_var = "A_", event_var = "event_"),
                            method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Causal effect in the treated sub-sample stratified on sites
    tTreatedE  <- try(coxph(formula = Surv(T_, event_) ~ A_ + strata(site),
                            data    = ValidateDf(x[x$A == 1,], expo_var = "A_", event_var = "event_"),
                            method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Causal effect in the untreated sub-sample stratified on sites
    tUntreatedE <- try(coxph(formula = Surv(T_, event_) ~ A_ + strata(site),
                            data    = ValidateDf(x[x$A == 0,], expo_var = "A_", event_var = "event_"),
                            method  = c("exact", "approximate", "efron", "breslow")[3]))
    ## Breslow
    ## Causal effect in the entire sample stratified on sites
    tAllB      <- try(coxph(formula = Surv(T_, event_) ~ A_ + strata(site),
                            data    = ValidateDf(x, expo_var = "A_", event_var = "event_"),
                            method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Causal effect in the treated sub-sample stratified on sites
    tTreatedB  <- try(coxph(formula = Surv(T_, event_) ~ A_ + strata(site),
                            data    = ValidateDf(x[x$A == 1,], expo_var = "A_", event_var = "event_"),
                            method  = c("exact", "approximate", "efron", "breslow")[4]))
    ## Causal effect in the untreated sub-sample stratified on sites
    tUntreatedB <- try(coxph(formula = Surv(T_, event_) ~ A_ + strata(site),
                             data    = ValidateDf(x[x$A == 0,], expo_var = "A_", event_var = "event_"),
                             method  = c("exact", "approximate", "efron", "breslow")[4]))

    list(tAllE       = CoefVar(tAllE, "A_"),
         tTreatedE   = CoefVar(tTreatedE, "A_"),
         tUntreatedE = CoefVar(tUntreatedE, "A_"),
         ## Breslow
         tAllB       = CoefVar(tAllB, "A_"),
         tTreatedB   = CoefVar(tTreatedB, "A_"),
         tUntreatedB = CoefVar(tUntreatedB, "A_"))
}


###  Combined
##' Analyze individual-level data collected from data centers (counterfactuals)
##'
##' Analyze individual-level data collected from data centers. Summary score matched analyses, stratified analyses, and weighted analyses are conducted stratifying on sites.
##'
##' @param x data frame generated by \code{\link{RequestSiteTruth}}, containing all variable including latent ones (e.g., counterfactuals).
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
AnalyzeSiteTruth <- function(x) {

    ##
    assert_that(is.data.frame(x))
    ## All variables including counter factuals need to exist
    assert_that(all(c("X1", "X2", "X3", "X4", "X5", "X6", "X7",
                      "pA", "A",
                      "pY", "pY0", "pY1", "Y",
                      "rate", "rate0", "rate1", "T", "C", "time", "event") %in% names(x)))

    ## Duplicate for counterfactuals
    x_A0 <- x
    x_A1 <- x
    ## Manipulate treatment
    x_A0$A_ <- 0
    x_A1$A_ <- 1
    ## Realize binary outcome under each manipulated treatments
    ## FIXME: Stochastic and not ideal, but should work over iterations
    x_A0$Y_ <- rbinom(n = seq_along(x_A0$pY), size = 1, prob = x_A0$pY0)
    x_A1$Y_ <- rbinom(n = seq_along(x_A1$pY), size = 1, prob = x_A1$pY1)
    ## Realize survival outcome under each manipulated treatment
    x_A0$T_ <- rexp(n = seq_along(x_A0$rate0), rate = x_A0$rate0)
    x_A1$T_ <- rexp(n = seq_along(x_A1$rate1), rate = x_A1$rate1)
    ## Everybody has observed survival time
    x_A0$event_ <- 1
    x_A1$event_ <- 1
    ## Create a counterfactual dataset containing everybody twice under both treatment
    ## All manipulated or counterfactuals are marked with *_ variable names.
    x_counterfactual <- rbind(x_A0, x_A1)

    ## Coefficients and variances as a matrix
    lstBin  <- AnalyzeSiteTruthBin(x_counterfactual)
    lstSurv <- AnalyzeSiteTruthSurv(x_counterfactual)
    matCoefVar <- do.call(rbind, c(lstBin, lstSurv))
    rownames(matCoefVar) <- NULL

    ## Name data
    out <- data.frame(data = rep("truth", nrow(matCoefVar)),
                      outcome = rep(c("binary","survival"),
                                    c(length(lstBin), length(lstSurv))),
                      method = c(names(lstBin),
                                 names(lstSurv)),
                      stringsAsFactors = FALSE)

    ## Combine and return
    cbind(out, matCoefVar)
}


###
### All analyses together
################################################################################

##' Analyze all analyses using data collected from data centers.
##'
##' Extract regression data from each site, and conducts meta-analyses. Extracts summary-level data from each site, and conducts summary-level conditional regression. Extracts risk sets data from each site, and conducts case-centered conditional logistic regression. Extracts individual-level data without covariates
##'
##' @param x \code{DistResNetReady} object prepared for analyses by \code{\link{RequestSiteDataPreparation}}.
##'
##' @return data frame populated with point estimates and variance estimates by various methods.
##'
##' @author Kazuki Yoshida
##'
##' @export
Analyze <- function(x) {
    ## Need to be analysis ready DistResNet object
    assert_that("DistResNetReady" %in% class(x))

    ## Analyze (Step-by-step to ease debugging)
    AnalysisSiteRegression <- AnalyzeSiteRegression(RequestSiteRegression(x))
    AnalysisSiteSummary    <- AnalyzeSiteSummary(RequestSiteSummary(x))
    AnalysisSiteRisksets   <- AnalyzeSiteRisksets(RequestSiteRisksets(x))
    AnalysisSiteDataset    <- AnalyzeSiteDataset(RequestSiteDataset(x))
    AnalysisSiteTruth      <- AnalyzeSiteTruth(RequestSiteTruth(x))

    ## Bind data together
    out <- dplyr::bind_rows(AnalysisSiteRegression,
                            AnalysisSiteSummary,
                            AnalysisSiteRisksets,
                            AnalysisSiteDataset,
                            AnalysisSiteTruth)

    ## Convert to factors to save space
    out$data    <- factor(out$data,
                          levels = c("meta", "summary", "risksets", "dataset", "truth"))
    out$outcome <- factor(out$outcome,
                          levels = c("binary", "survival"))
    ## Do not specify levels as they are subject to change
    out$method  <- factor(out$method)

    ## Order for readability
    out <- dplyr::arrange_(out, "data", "outcome", "method")

    ## Return
    out
}
